---
title: "Allometry in LUMCON marshes"
author: ""
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>" 
)

if(!require(knitr)){
  install.packages("knitr", repos='http://cran.us.r-project.org')
}
if(!require(rmarkdown)){
  install.packages("rmarkdown", repos='http://cran.us.r-project.org')
}
if(!require(plyr)){
  install.packages("plyr", repos='http://cran.us.r-project.org')
}
if(!require(reshape2)){
  install.packages("reshape2", repos='http://cran.us.r-project.org')
}
if(!require(ggplot2)){
  install.packages("ggplot2", repos='http://cran.us.r-project.org')
}
if(!require(scales)){
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(MuMIn)){
  install.packages("MuMIn", repos='http://cran.us.r-project.org')
}
if(!require(rsq)){
  install.packages("rsq", repos='http://cran.us.r-project.org')
}


library(ggplot2)
library(plyr)
library(LUMCONplants)

# library(multcomp) # for glht
# library(sandwich) # for HC3 estimator
# library(car) # for Levene's test

### define some constants
plotSize       <- 0.25 * 0.25  # size of quadrat, m2
coreTube       <- pi*(6.9/2)^2 # area of plastic coring tube: cm2 
coreTube_metal <- pi*(6.0/2)^2 # area of metal coring device: cm2 
bagMass        <- 5.4          # grams; bags used for belowground cores

tckSize        <- 0.01


```


```{r allometry models, echo = FALSE, include = FALSE, message = FALSE}

stemDat$moYr  <- paste0(stemDat$mo, "-", substr(stemDat$yr, 3, 4))
stemDat$time  <- as.yearmon(stemDat$moYr, "%b-%y")
stemDat       <- seasonLabel(data = stemDat)
stemDat$seas  <- substr(stemDat$season, 1, 4)
stemDat$plantYr <- as.numeric(paste0(20, substr(stemDat$season, 6, 7))) # doesn't split winter samples (Jan 2018 is in winter 2017)


### separate plot As for allometry work
stm <- stemDat[stemDat$plot %in% "A", ]



### allometry models
# nls(mass_tot ~ I(a * hgt^b), start = list(a = 0.2, b = 0.2), data = stm[(stm$site %in% "LUM1") & (stm$status %in% "LIVE") & (stm$seas %in% "fall"), ])
# models <- dlply(stm, .(site, season, status), function(x) 
#   nls(mass_tot ~ I(a * hgt^b), start = list(a = 0.2, b = 0.2), data = x)) 
# ldply(models, coef)

models.hiRes <- ddply(stm, .(site, seas), function(x) 
  getParams(dataset = x))
models.reg <- ddply(stm, .(region, seas, plantYr), function(x) 
  getParams(dataset = x))

models            <- ddply(stm, .(region, seas), function(x) 
  getParams(dataset = x))
dead.allom        <- getParams(dataset = stm)
dead.allom$region <- "all"
dead.allom$seas   <- "all"

models <- rbind.fill(models, dead.allom)


exponents_vs_coefs <- ggplot(aes(y = exp.live, x = coef.live, colour = seas), data = models) + geom_point() + theme_classic() + labs(y = "exponent", x = "coefficient")
# spring = low coefficients, high exponents


allom_by_seas <- ggplot(aes(y = mass_tot, x = hgt, colour = site), 
       data = stm[(stm$region %in% "LUMCON") & (stm$status %in% "LIVE"), ]) + 
  geom_point() + theme_classic() + labs(y = "mass", x = "hgt") + 
  facet_grid(seas ~ plantYr)




# Apply allometry to un-weighed stems -------------------------------------

### Generate estimates from season-region models and pooled data 
for (i in 1:nrow(stemDat)) {
  # identify region and season
  targRegion <- stemDat$region[i]
  targetSeas <- stemDat$seas[i]
  
  # find seasonal allometry parameters for the region
  if (stemDat$status[i] %in% "LIVE") {
    coefficient <- models$coef.live[(models$region %in% targRegion) & (models$seas %in% targetSeas)]
    exponent    <- models$exp.live[(models$region %in% targRegion) & (models$seas %in% targetSeas)]
  } else if (stemDat$status[i] %in% "DEAD") {
    coefficient <- models$coef.dead[(models$region %in% "all") & (models$seas %in% "all")]
    exponent    <- models$exp.dead[(models$region %in% "all") & (models$seas %in% "all")]
  }
  # apply allometry to get mass estimate
  stemDat$mass.est1[i] <- coefficient * (stemDat$hgt[i] ^ exponent) # season-region models for live, pooled model for dead
  if (stemDat$status[i] %in% "LIVE") {
    stemDat$mass.est2[i] <- models$coef.live[(models$region %in% "all")] * (stemDat$hgt[i] ^ models$exp.live[(models$region %in% "all")]) # single model for all data (always used for dead stems)
  } else {
    stemDat$mass.est2[i] <- NA
  }
  
  # define final mass to be used
  # set dummy variable if plant mass was actually measured
  if (!is.na(stemDat$mass_tot[i])) {
    stemDat$modeled[i] <- 0
    stemDat$mass[i]    <- stemDat$mass_tot[i]
  } else {
    stemDat$modeled[i] <- 1
    stemDat$mass[i]    <- stemDat$mass.est1[i]
  }
}


```


```{r aggregate to plot-level data, echo = FALSE, include = FALSE, message = FALSE}

```


```{r trends in stem demographics, echo = FALSE, include = FALSE, message = FALSE}

getDemographics <- function(data = stemDat, status = "LIVE", groupBreaks = c(0, 25, 50, 100, 200), groupLabels = c("0-25 cm", "25-50 cm", "50-100 cm", ">100 cm"), quadrat_m2 = 1) {
  df1 <- transform(data[(data$status %in% status), ], group = cut(hgt, 
             breaks = groupBreaks,
             labels = groupLabels))
  res <- do.call(data.frame, aggregate(hgt ~ time + group, df1, 
             FUN = function(x) c(count = sum(!is.na(x)) / quadrat_m2, mean = mean(x, na.rm = TRUE) / quadrat_m2)))
  dNew <- data.frame(group = levels(df1$group))
  df2 <- merge(res, dNew, all = TRUE)
  
  # add missing bins, set to 0 hgt/dens
  missedLevs <- expand.grid(time = unique(res$time), group = unique(res$group), hgt.count = 0, hgt.mean = 0)
  missingLevs <- missedLevs[which(!paste0(missedLevs$time, missedLevs$group) %in% paste0(res$time, res$group)), ]
  df2 <- rbind(df2, missingLevs)
  #df2$site <- targReg
  invisible(df2)
}

### get demographics by plot
int_df  <- ddply(stemDat, .(region, site, plot), function(x) 
  getDemographics(x, quadrat_m2 = plotSize))

### mean by marsh
final_df <- ddply(int_df, .(region, site, group, time), summarise, 
                  stmDens    = mean(hgt.count, na.rm = TRUE),
                  stmDens.se = se(hgt.count),
                  hgt        = mean(hgt.mean, na.rm = TRUE),
                  hgt.se    = se(hgt.mean))

stm.demographics <- ggplot(final_df[final_df$region %in% "LUMCON",], 
       aes(y = stmDens, x = as.numeric(time))) + #, col = region)) + 
  geom_point(size = 1.2) + geom_errorbar(aes(ymin = (stmDens - stmDens.se), ymax = (stmDens + stmDens.se)), width = 0) +
  geom_line(lwd = 0.7) +
  theme_classic() + theme(legend.title = element_blank()) + 
  ylab(expression("Live stem density (m"^-2~")")) + xlab("") + 
  facet_wrap("group", nrow = 2) + 
  theme_bw() %+replace% theme(strip.background  = element_blank(), legend.title = element_blank())


# identify seasonality
for (i in 1:length(unique(final_df$group)[1:3])) {
  test <- ts(final_df[(final_df$region %in% "LUMCON") & 
                        (final_df$group %in% unique(final_df$group)[i]), "stmDens"], 
            start = c(12, 5), deltat = 1/12)
  test2 <- stl(test, s.window = 12)
  print(apply(test2$time.series, 2, var) / var(test))
  
  # evaluate change as the difference between start and end values of the trend component 
  print(noquote(paste0("trend for stems in ", unique(final_df$group)[i], " size class: ",
                       round(as.numeric(test2$time.series[nrow(test2$time.series), 2] - test2$time.series[1, 2])))))
}
 # no obvious trends

```


## Allometry data

```{r allometry by season-year, fig.width = 6, fig.height = 6, echo=FALSE, warning=FALSE, fig.cap = "Mass-height allometry at LUMCON marshes, by season (rows) and year (columns)."}

allom_by_seas

```



```{r allometry exponents and coefficients, fig.width = 3, fig.height = 3, warning=FALSE, echo=FALSE, fig.cap = "Relationship between allometry coefficients and exponents (one model for each marsh-season)."}

exponents_vs_coefs

```



```{r stem demographics, fig.width = 6, fig.height = 4, echo=FALSE, warning=FALSE, fig.cap = "Temporal trends in stem size classes at LUMCON marshes."}

stm.demographics

```


